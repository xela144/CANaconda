TO DO:
 * Make the code work from the command line when no PyQt5 installed


TO IMPROVE:
 * To test functionality w/o certain libraries, use `virtualenv`. This lets you run 
   multiple instances of Python with their own packages.
 * Add a global reset button. This code should be executed when a new xml file is 
   __successfully__ loaded, and not before.
 * Ignore error when filters are loaded when raw message viewing has already begun.
 * Make FromValue field more clear
 * While waiting for the first carriage return, show hourglass cursor
 * Support current xmltest.txt file (the Instance field for PGN 130311)
 * Restrict files to select only '.xml' files in the file selector dialog
 * Remove debugging output from program; only output error messages. You should 
   use either stderr or QT's error output when doing this.
 * Specifying a filter for a data field should not show that message in the window 
   at all even if other data fields in that message don't have a filter. 
   The filter should be specified by field but applied per message.
 * Change "Display opts:" to "Display"
  * Also remove Body, PGN, and ID options. Always display everything the user 
    has selected. Change the Hex,CSV checkboxes into a dropdown with the 3 
    primary options: "Decoded", "Raw hex", and "CSV". 
 * Change "Begin Logging" button into "Start logging as CSV" so it's more clear 
   what it does since we have the space for that extra text.
 * Move the Display Options up to below the message stream window.
 * Move the logging stuff into it's own groupbox spanning the bottom of the 
   window with the button on the left, followed by the desired file name, 
   followed by a status ("RECORDING" or "STOPPED"), followed by the number 
   messages that have been recorded into this log.
 * Unknown units in the units column shouldn't result in it being a textfield, 
   just make it an uneditable QLabel instead.
 * Change "Name" column to "Message" in the "Units and filtering by value" tab.
 * Don't allow sorting the "Units and filtering by value" table by latest value.
 * Put a messages/second column in Hz in the table. If Hz<1, use T in seconds. 
   Otherwise use Hz as units.


I'd also like to be able to filter by multiple identical IDs or PGN numbers
with possibly different conditions. This means that you will probably want
to convert you dictionary/set of filter objects to actually be a dict/set of
lists containing all of the views related to those IDs or PGNs.

For example, I have a message with an ID 90, where the first byte indicates
which node is transmitting this message. So I'd like to see the data from
these messages independently. For example if I have my rudder node and my RC
node, I'll see messages like {ID:90, data:[3 ...]} and {ID:90, data:[2 ...]},
but I'd want them shown separately. Something like
--filters='NODE_STATUS[node=3],NODE_STATUS[node=2]{status,errors}, where this
would indicate that I want to see data from two separate instances of the
NODE_STATUS message, one where the 'node' field is 3 (and all of its fields),
and another where the 'node' field is 2 (and I only want to see the 'status'
and 'errors' fields.

--filter='NODE_STATUS[node=3],NODE_STATUS[node=2]{status,errors}
--filter='WSO100[airspeed=3]{wind_dir},NODE_STATUS[node=2]{status,errors}
--filter='WSO100{airspeed=3,wind_dir},NODE_STATUS{node=2,status,errors}

output:
{ID:90, body:[3 ...]}
{ID:90, body:[2 ...]}

